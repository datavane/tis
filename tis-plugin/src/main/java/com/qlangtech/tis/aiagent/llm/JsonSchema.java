/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * <p> * http://www.apache.org/licenses/LICENSE-2.0 * <p> * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.qlangtech.tis.aiagent.llm;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.google.common.collect.Lists;import com.google.common.collect.Sets;import com.qlangtech.tis.extension.Descriptor;import com.qlangtech.tis.manage.common.Option;import com.qlangtech.tis.util.DescriptorsJSONForAIPrompt;import org.apache.commons.lang.StringUtils;import java.io.BufferedReader;import java.io.StringReader;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Objects;import java.util.Optional;import java.util.Set;import java.util.function.Consumer;import java.util.regex.Pattern;import java.util.stream.Collectors;import static com.qlangtech.tis.extension.Descriptor.KEY_DESC_VAL;/** * * @author 百岁 (baisui@qlangtech.com) * @date 2025/12/28 */public abstract class JsonSchema {    public static final String SCHEMA_NAME = "name";    public static final String SCHEMA_TYPE = "type";    public static final String SCHEMA_DESC = "description";    public static final String SCHEMA_RERUIRED = "required";    public static final String SCHEMA_PROPERTIES = "properties";    public static final String SCHEMA_ONE_OF = "oneOf";    public static final String SCHEMA_VALUE_DEFAULT = "default";    public static final String SCHEMA_VALUE_CONST = "const";    public static final String SCHEMA_VALUE_ENUM = "enum";    public static final String SCHEMA_VALUE_PATTERN = "pattern";    public static final String SCHEMA_PLUGIN_DESCRIPTOR_ID = "id";    public abstract boolean isContainSchema();    /**     *     * @return     */    public abstract String getSchemaName();    public List<Option> getFieldsDesc() {        return Collections.emptyList();    }    public void appendFieldDescToPrompt(StringBuilder prompt) {        this.appendFieldDescToPrompt(prompt, this.getFieldsDesc(), 0);    }    public void appendFieldDescToPrompt(StringBuilder prompt, List<Option> fieldsDesc, final int indentCount) {        int num = 1;        for (Option option : fieldsDesc) {            startNewLine(prompt, indentCount);            prompt.append((num++)).append(". ").append("`").append(option.getName()).append("`");            Object desc = option.getValue();            if (desc == null) {                continue;            }            if (desc instanceof OneOfFieldsDesc) {                OneOfFieldsDesc oneOfFieldsDesc = ((OneOfFieldsDesc) desc);                //prompt.append(" : ").append(oneOfFieldsDesc.getHelp());                appendHelp(prompt, indentCount, oneOfFieldsDesc.getHelp());                for (Map.Entry<String, OneOfFieldsDesc.PluginDesc> entry : oneOfFieldsDesc.entrySet()) {                    // System.out.println(" " + entry.getKey());                    startNewLine(prompt, indentCount + 1).append("* `").append(SCHEMA_PLUGIN_DESCRIPTOR_ID).append("`").append("属性为:").append(entry.getValue().pluginDisplayName);                    this.appendFieldDescToPrompt(prompt, entry.getValue().fieldsDesc, indentCount + 2);                    //                    for (Option child : entry.getValue()) {                    //                        System.out.println("\t" + child.getName());                    //                    }                }            } else {                appendHelp(prompt, indentCount, (String) desc);            }        }    }    private void appendHelp(StringBuilder prompt, int indentCount, String desc) {        try (BufferedReader linesReader = new BufferedReader(new StringReader(desc))) {            List<String> lines = linesReader.lines().collect(Collectors.toList());            if (lines.size() > 1) {                prompt.append(" : ");                lines.forEach((line) -> {                    startNewLine(prompt, indentCount + 1).append(line);                });            } else if (lines.size() == 1) {                prompt.append(" : ").append(lines.get(0));            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    private static StringBuilder startNewLine(StringBuilder prompt, final int indentCount) {        prompt.append("\n");        if (indentCount > 0) {            int spaceCount = indentCount * 3;            while (spaceCount-- > 0) {                prompt.append(" ");            }        }        return prompt;    }    public abstract JSONObject root();    /**     *     * @return     */    public abstract JSONObject schema();    /**     * @param root     * @param schema     <pre>     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {	"type": "object",     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               		"properties": {     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "required": ["host"], // 根据实际结构，可能需要调整必填项     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     "additionalProperties": false     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </pre>     * @param fieldsDesc 字段描述     * @return     */    public static JsonSchema create(JSONObject root, JSONObject schema, List<Option> fieldsDesc) {        return new JsonSchemaOn(root, schema, fieldsDesc);    }    public static JsonSchema off() {        return new JsonSchemaOff();    }    private static class JsonSchemaOff extends JsonSchema {        public JsonSchemaOff() {        }        @Override        public boolean isContainSchema() {            return false;        }        @Override        public JSONObject root() {            return null;        }        @Override        public JSONObject schema() {            return null;        }        @Override        public String getSchemaName() {            return null;        }    }    public static class Builder {        private final Optional<String> parentKey;        private final JSONObject rootSchema;        private final JSONObject properties;        private final JSONObject schemaProperties;        /**         * 属性描述列表         */        private final List<Option> fieldsDesc = Lists.newArrayList();        private final Set<String> requiredFields = Sets.newHashSet();        public static Builder create(String schemaName, Optional<String> parentKey) {            return new Builder(schemaName, parentKey);        }        private Builder(String schemaName, Optional<String> parentKey) {            this.rootSchema = new JSONObject();            this.parentKey = parentKey;            this.rootSchema.put(SCHEMA_NAME, schemaName);            this.schemaProperties = new JSONObject();            this.rootSchema.put("schema", schemaProperties);            //"type"            schemaProperties.put(SCHEMA_TYPE, FieldType.Object.token);            this.properties = new JSONObject();            schemaProperties.put(SCHEMA_PROPERTIES, this.properties);            rootSchema.put("strict", true);        }        private Builder setRequiredFields(String... requiredField) {            JSONArray requriredProps = new JSONArray();            requriredProps.addAll(Lists.newArrayList(requiredField));            this.schemaProperties.put(SCHEMA_RERUIRED, requriredProps);            return this;        }        public void addOneOfProperty(DescriptorsJSONForAIPrompt.AISchemaAttrVal attrVal,                                     List<? extends Descriptor> applicableDescriptors, boolean required) {            final String propertyKey = attrVal.getFieldKey();            JSONObject property = new JSONObject();            JSONArray oneOf = new JSONArray();            DescriptorsJSONForAIPrompt descriptorsJSONForAIPrompt =                    new DescriptorsJSONForAIPrompt(applicableDescriptors, false);            DescriptorsJSONForAIPrompt.AISchemaDescriptorsMeta schemaDescriptorsMeta //                    =                    (DescriptorsJSONForAIPrompt.AISchemaDescriptorsMeta) descriptorsJSONForAIPrompt.getDescriptorsJSON();            OneOfFieldsDesc oneOfFieldsDesc = new OneOfFieldsDesc();            for (Map.Entry<String /* concrete plugin implement class */, JsonSchema> entry :                    schemaDescriptorsMeta.descSchemaRegister.entrySet()) {                Builder schemaBuilder = createInnerSchemaBuilder(propertyKey);                // Builder.create(entry.getKey(), this.parentKey);                JsonSchema jsonSchema = entry.getValue();                schemaBuilder.addObjectProperty(KEY_DESC_VAL, (descBuilder) -> {                    descBuilder.setSchema(jsonSchema);                });                schemaBuilder.addProperty(SCHEMA_PLUGIN_DESCRIPTOR_ID, FieldType.String, "代表本`" + SCHEMA_ONE_OF + "`之一的标识符", false).setConst(jsonSchema.getSchemaName());                oneOf.add(schemaBuilder.build().schema());                oneOfFieldsDesc.setPluginConcreteClassRelevant(entry.getKey(), schemaBuilder.fieldsDesc,jsonSchema.getSchemaName());                //  System.out.println(schemaBuilder.fieldsDesc.size());            }            // this.fieldsDesc.add(new Option(propertyKey, oneOfFieldsDesc));            addFieldsDesc(propertyKey, oneOfFieldsDesc);            // this.fieldsDesc.addAll(builder.fieldsDesc);            property.put(SCHEMA_ONE_OF, oneOf);            String help = attrVal.getHelp();            if (StringUtils.isNotEmpty(help)) {                oneOfFieldsDesc.help = help;                property.put(SCHEMA_DESC, help);            }            if (required) {                this.requiredFields.add(propertyKey);            }            properties.put(propertyKey, property);        }        private void setSchema(JsonSchema schema) {            this.schemaProperties.putAll(schema.schema());            List<Object> required = this.schemaProperties.getJSONArray(SCHEMA_RERUIRED);            this.requiredFields.addAll(Sets.newHashSet(required.toArray(String[]::new)));            for (Option fieldDesc : schema.getFieldsDesc()) {                this.fieldsDesc.add(new Option(this.parentKey.map((parent) -> parent + ".").orElse(StringUtils.EMPTY) + fieldDesc.getName(), fieldDesc.getValue()));            }        }        public AddedProperty addProperty(String propertyKey, FieldType type, String description) {            return addProperty(propertyKey, type, description, true);        }        public AddedProperty addProperty(String propertyKey, FieldType type, String description, boolean required) {            JSONObject property = new JSONObject();            property.put(SCHEMA_TYPE, type.token);            property.put(SCHEMA_DESC, description);            properties.put(propertyKey, property);            if (required) {                this.requiredFields.add(propertyKey);            }            this.addFieldsDesc(propertyKey, description);            return new AddedProperty(property);        }        private void addFieldsDesc(String propertyKey, Object description) {            this.fieldsDesc.add(new Option(this.parentKey.map((parent) -> parent + ".").orElse(StringUtils.EMPTY) + propertyKey, description));        }        public void addObjectProperty(String propertyKey, Consumer<Builder> subFieldCreator) {            Builder builder = createInnerSchemaBuilder(propertyKey);            subFieldCreator.accept(builder);            builder.build();            this.fieldsDesc.addAll(builder.fieldsDesc);            this.requiredFields.add(propertyKey);            properties.put(propertyKey, builder.schemaProperties);        }        private Builder createInnerSchemaBuilder(String propertyKey) {            Builder builder = Builder.create(propertyKey,                    this.parentKey.map((parent) -> parent + "." + propertyKey).or(() -> Optional.of(propertyKey)));            return builder;        }        public JsonSchema build() {            this.setRequiredFields(this.requiredFields.toArray(String[]::new));            this.schemaProperties.put("additionalProperties", false);            return JsonSchema.create(rootSchema, this.schemaProperties, this.fieldsDesc);        }    }    public static class AddedProperty {        private final JSONObject property;        public AddedProperty(JSONObject property) {            this.property = property;        }        public AddedProperty setValEnums(Object... vals) {            JSONArray enums = new JSONArray();            enums.addAll(Lists.newArrayList(vals));            property.put(SCHEMA_VALUE_ENUM, enums);            return this;        }        public AddedProperty setDefault(Object dft) {            property.put(SCHEMA_VALUE_DEFAULT, dft);            return this;        }        public AddedProperty setConst(Object val) {            property.put(SCHEMA_VALUE_CONST, val);            return this;        }        public void setPattern(Pattern pattern) {            property.put(SCHEMA_VALUE_PATTERN, Objects.requireNonNull(pattern, "pattern can not be null").pattern());        }    }    private static class JsonSchemaOn extends JsonSchema {        private final JSONObject root;        private final JSONObject schema;        private final List<Option> fieldsDesc;        private JsonSchemaOn(JSONObject root, JSONObject schema, List<Option> fieldsDesc) {            this.root = Objects.requireNonNull(root, "root can not be null");            this.schema = Objects.requireNonNull(schema, "schema can not be null");            this.fieldsDesc = fieldsDesc;        }        @Override        public List<Option> getFieldsDesc() {            return this.fieldsDesc;        }        @Override        public JSONObject schema() {            return this.schema;        }        @Override        public boolean isContainSchema() {            return true;        }        @Override        public JSONObject root() {            return root;        }        @Override        public final String getSchemaName() {            return this.root.getString(SCHEMA_NAME);        }    }    public enum FieldType {        String("string"), Boolean("boolean"), Array("array"), Number("number"), Integer("integer"), Object("object");        public final String token;        private FieldType(String token) {            this.token = token;        }    }    public static class OneOfFieldsDesc //            extends HashMap<String /* concrete plugin implement class */, OneOfFieldsDesc.PluginDesc> {        private String help;        public OneOfFieldsDesc() {            super();        }        public String getHelp() {            return StringUtils.trimToEmpty(this.help);        }        public void setPluginConcreteClassRelevant(String pluginConcreteClass, List<Option> fieldsDesc, String pluginDisplayName) {            this.put(pluginConcreteClass, new PluginDesc(fieldsDesc, pluginDisplayName));        }        public List<Option> getPluginFieldsDesc(String pluginConcreteClass) {            return Objects.requireNonNull(this.get(pluginConcreteClass),                    "pluginConcreteClass:" + pluginConcreteClass + " relevant opts can not be null").fieldsDesc;        }        public String getPluginDisplayName(String pluginConcreteClass) {            return Objects.requireNonNull(this.get(pluginConcreteClass),                    "pluginConcreteClass:" + pluginConcreteClass + " relevant opts can not be null").pluginDisplayName;        }        public static class PluginDesc {            private final List<Option> fieldsDesc;            private final String pluginDisplayName;            public PluginDesc(List<Option> fieldsDesc, String pluginDisplayName) {                this.fieldsDesc = fieldsDesc;                this.pluginDisplayName = pluginDisplayName;            }        }    }}